# ECE 449 Intelligent Systems Engineering
# Fall 2023
# Ivan Eisenbarth

from kesslergame import KesslerController # In Eclipse, the name of the library is kesslergame, not src.kesslergame
from typing import Dict, Tuple
import skfuzzy as fuzz
from skfuzzy import control as ctrl
import math
import numpy as np


#Made to return a more accurate representation of the distance of each of the asteroids
def relative_pos(ast_x, ast_y, ast_v_x, ast_v_y, space_x, space_y, space_v_x, space_v_y,ast_size):
    # Calculate relative velocity components
    relative_vel_x = space_v_x - ast_v_x
    relative_vel_y = space_v_y - ast_v_y

    # Predict future position of the asteroid
    future_ast_x = ast_x+ast_size + relative_vel_x*1/30
    future_ast_y = ast_y+ast_size + relative_vel_y*1/30

    # Calculate Euclidean distance between current spaceship and predicted asteroid positions
    distance = math.sqrt((future_ast_x - space_x) ** 2 + (future_ast_y - space_y) ** 2)
    return distance
class IvanController(KesslerController):
    
        
    def __init__(self):
        self.eval_frames = 0 #What is this?

        # self.targeting_control is the targeting rulebase, which is static in this controller.      
        # Declare variables
        bullet_time = ctrl.Antecedent(np.arange(0,1.0,0.002), 'bullet_time')
        theta_delta = ctrl.Antecedent(np.arange(-180,180,1), 'theta_delta') # Radians due to Python
        ship_turn = ctrl.Consequent(np.arange(-180,180,1), 'ship_turn') # Degrees due to Kessler
        ship_fire = ctrl.Consequent(np.arange(-1,1,0.1), 'ship_fire')
        
        #Declare fuzzy sets for bullet_time (how long it takes for the bullet to reach the intercept point)
        bullet_time['S'] = fuzz.trimf(bullet_time.universe,[0,0,0.05])
        bullet_time['M'] = fuzz.trimf(bullet_time.universe, [0,0.05,0.1])
        bullet_time['L'] = fuzz.smf(bullet_time.universe,0.0,0.1)
        
        #Declare fuzzy sets for theta_delta (degrees of turn needed to reach the calculated firing angle)
        theta_delta['NXL'] = fuzz.zmf(theta_delta.universe,-180,-120)
        theta_delta['NL'] = fuzz.trimf(theta_delta.universe, [-135,-90,-45])
        theta_delta['NS'] = fuzz.trimf(theta_delta.universe, [-60,-30,0])
        theta_delta['Z'] = fuzz.trimf(theta_delta.universe, [-15,0,15])
        theta_delta['PS'] = fuzz.trimf(theta_delta.universe, [0,30,60])
        theta_delta['PL'] = fuzz.trimf(theta_delta.universe, [45,90,135])
        theta_delta['PXL'] = fuzz.smf(theta_delta.universe,120,180)
        
        #Declare fuzzy sets for the ship_turn consequent; this will be returned as turn_rate.
        ship_turn['NXL'] = fuzz.trimf(ship_turn.universe, [-180,-180,-120])
        ship_turn['NL'] = fuzz.trimf(ship_turn.universe, [-135,-90,-45])
        ship_turn['NS'] = fuzz.trimf(ship_turn.universe, [-60,-30,0])
        ship_turn['Z'] = fuzz.trimf(ship_turn.universe, [-15,0,15])
        ship_turn['PS'] = fuzz.trimf(ship_turn.universe, [0,30,60])
        ship_turn['PL'] = fuzz.trimf(ship_turn.universe, [45,90,135])
        ship_turn['PXL'] = fuzz.trimf(ship_turn.universe, [120,180,180])
        
        #Declare singleton fuzzy sets for the ship_fire consequent; -1 -> don't fire, +1 -> fire; this will be  thresholded
        #   and returned as the boolean 'fire'
        ship_fire['N'] = fuzz.trimf(ship_fire.universe, [-1,-1,0.0])
        ship_fire['Y'] = fuzz.trimf(ship_fire.universe, [0.0,1,1]) 
                
        #Declare each fuzzy rule
        rule1 = ctrl.Rule(bullet_time['L'] & theta_delta['NXL'], (ship_turn['NXL'], ship_fire['N']))
        rule2 = ctrl.Rule(bullet_time['L'] & theta_delta['NL'], (ship_turn['NXL'], ship_fire['N']))
        rule3 = ctrl.Rule(bullet_time['L'] & theta_delta['NS'], (ship_turn['NL'], ship_fire['Y']))
        rule4 = ctrl.Rule(bullet_time['L'] & theta_delta['Z'], (ship_turn['Z'], ship_fire['Y']))
        rule5 = ctrl.Rule(bullet_time['L'] & theta_delta['PS'], (ship_turn['PL'], ship_fire['Y']))
        rule6 = ctrl.Rule(bullet_time['L'] & theta_delta['PL'], (ship_turn['PXL'], ship_fire['N']))
        rule7 = ctrl.Rule(bullet_time['L'] & theta_delta['PXL'], (ship_turn['PXL'], ship_fire['N']))

        rule8 = ctrl.Rule(bullet_time['M'] & theta_delta['NXL'], (ship_turn['NXL'], ship_fire['N']))     
        rule9 = ctrl.Rule(bullet_time['M'] & theta_delta['NL'], (ship_turn['NXL'], ship_fire['N']))
        rule10 = ctrl.Rule(bullet_time['M'] & theta_delta['NS'], (ship_turn['NXL'], ship_fire['Y']))
        rule11 = ctrl.Rule(bullet_time['M'] & theta_delta['Z'], (ship_turn['Z'], ship_fire['Y']))    
        rule12 = ctrl.Rule(bullet_time['M'] & theta_delta['PS'], (ship_turn['PXL'], ship_fire['Y']))
        rule13 = ctrl.Rule(bullet_time['M'] & theta_delta['PL'], (ship_turn['PXL'], ship_fire['N']))
        rule14 = ctrl.Rule(bullet_time['M'] & theta_delta['PXL'], (ship_turn['PXL'], ship_fire['N']))

        rule15 = ctrl.Rule(bullet_time['S'] & theta_delta['NXL'], (ship_turn['NXL'], ship_fire['N']))
        rule16 = ctrl.Rule(bullet_time['S'] & theta_delta['NL'], (ship_turn['NXL'], ship_fire['N']))
        rule17 = ctrl.Rule(bullet_time['S'] & theta_delta['NS'], (ship_turn['NS'], ship_fire['N']))
        rule18 = ctrl.Rule(bullet_time['S'] & theta_delta['Z'], (ship_turn['Z'], ship_fire['Y']))
        rule19 = ctrl.Rule(bullet_time['S'] & theta_delta['PS'], (ship_turn['PS'], ship_fire['N']))
        rule20 = ctrl.Rule(bullet_time['S'] & theta_delta['PL'], (ship_turn['PXL'], ship_fire['N']))
        rule21 = ctrl.Rule(bullet_time['S'] & theta_delta['PXL'], (ship_turn['PXL'], ship_fire['N']))
     
        #DEBUG
        #bullet_time.view()
        #theta_delta.view()
        #ship_turn.view()
        #ship_fire.view()

        # Declare the fuzzy controller, add the rules
        self.targeting_control = ctrl.ControlSystem()
        self.targeting_control.addrule(rule1)
        self.targeting_control.addrule(rule2)
        self.targeting_control.addrule(rule3)
        self.targeting_control.addrule(rule4)
        self.targeting_control.addrule(rule5)
        self.targeting_control.addrule(rule6)
        self.targeting_control.addrule(rule7)
        self.targeting_control.addrule(rule8)
        self.targeting_control.addrule(rule9)
        self.targeting_control.addrule(rule10)
        self.targeting_control.addrule(rule11)
        self.targeting_control.addrule(rule12)
        self.targeting_control.addrule(rule13)
        self.targeting_control.addrule(rule14)
        self.targeting_control.addrule(rule15)
        self.targeting_control.addrule(rule16)
        self.targeting_control.addrule(rule17)
        self.targeting_control.addrule(rule18)
        self.targeting_control.addrule(rule19)
        self.targeting_control.addrule(rule20)
        self.targeting_control.addrule(rule21)

        #Start of Ivan's Fuzzy Logic for Evade Mode
        rel_ast_dist = ctrl.Antecedent(np.arange(0,700,1),'rel_ast_dist')
        rel_ast_angl = ctrl.Antecedent(np.arange(-180,180,1), 'rel_ast_angl')
        ship_thrust = ctrl.Consequent(np.arange(-175,175,1),'ship_thrust')

        #Define each of the new inputs and outputs
        rel_ast_dist['NL'] = fuzz.zmf(rel_ast_dist.universe,0,100)
        rel_ast_dist['NS'] = fuzz.trimf(rel_ast_dist.universe, [50,150,275])
        rel_ast_dist['Z'] = fuzz.trimf(rel_ast_dist.universe, [225,350,475])
        rel_ast_dist['PS'] = fuzz.trimf(rel_ast_dist.universe, [425,550,650])
        rel_ast_dist['PL'] = fuzz.smf(rel_ast_dist.universe,600,700)

        rel_ast_angl['NXL'] = fuzz.trimf(rel_ast_angl.universe, [-180,-180,-120])
        rel_ast_angl['NL'] = fuzz.trimf(rel_ast_angl.universe, [-135,-90,-45])
        rel_ast_angl['NS'] = fuzz.trimf(rel_ast_angl.universe, [-60,-30,-0])
        rel_ast_angl['Z'] = fuzz.trimf(rel_ast_angl.universe, [-15,0,15])
        rel_ast_angl['PS'] = fuzz.trimf(rel_ast_angl.universe, [0,30,60])
        rel_ast_angl['PL'] = fuzz.trimf(rel_ast_angl.universe, [45,90,135])
        rel_ast_angl['PXL'] = fuzz.trimf(rel_ast_angl.universe, [120,180,180])
          
        ship_thrust['NL'] = fuzz.zmf(ship_thrust.universe,-120,-90)
        ship_thrust['NS'] = fuzz.trimf(ship_thrust.universe, [-100,-75,-50])
        ship_thrust['Z'] = fuzz.trimf(ship_thrust.universe, [-50,0,50])
        ship_thrust['PS'] = fuzz.trimf(ship_thrust.universe, [50,75,100])
        ship_thrust['PL'] = fuzz.smf(ship_thrust.universe,90,120)

        #Declare each fuzzy rule for the Evade Mode
        rule1_evade = ctrl.Rule((rel_ast_angl['NXL'] & rel_ast_dist['NL']), (ship_turn['Z'], ship_thrust['PL'],ship_fire['Y']))
        rule2_evade = ctrl.Rule((rel_ast_angl['NXL'] & rel_ast_dist['NS']), (ship_turn['Z'], ship_thrust['PL'],ship_fire['N']))
        rule3_evade = ctrl.Rule((rel_ast_angl['NXL'] & rel_ast_dist['Z']), (ship_turn['PXL'], ship_thrust['PL'],ship_fire['N']))
        rule4_evade = ctrl.Rule((rel_ast_angl['NXL'] & rel_ast_dist['PS']), (ship_turn['PXL'], ship_thrust['PL'],ship_fire['N']))
        rule5_evade = ctrl.Rule((rel_ast_angl['NXL'] & rel_ast_dist['PL']), (ship_turn['PXL'], ship_thrust['PS'],ship_fire['N']))

        rule6_evade = ctrl.Rule((rel_ast_angl['NL'] & rel_ast_dist['NL']), (ship_turn['PXL'], ship_thrust['PL'],ship_fire['N']))
        rule7_evade = ctrl.Rule((rel_ast_angl['NL'] & rel_ast_dist['NS']), (ship_turn['PXL'], ship_thrust['PL'],ship_fire['N']))
        rule8_evade = ctrl.Rule((rel_ast_angl['NL'] & rel_ast_dist['Z']), (ship_turn['PXL'], ship_thrust['PS'],ship_fire['N']))
        rule9_evade = ctrl.Rule((rel_ast_angl['NL'] & rel_ast_dist['PS']), (ship_turn['PL'], ship_thrust['PS'],ship_fire['N']))
        rule10_evade = ctrl.Rule((rel_ast_angl['NL'] & rel_ast_dist['PL']), (ship_turn['PL'], ship_thrust['PS'],ship_fire['N']))

        rule11_evade = ctrl.Rule((rel_ast_angl['NS'] & rel_ast_dist['NL']), (ship_turn['NL'], ship_thrust['NS'],ship_fire['Y']))
        rule12_evade = ctrl.Rule((rel_ast_angl['NS'] & rel_ast_dist['NS']), (ship_turn['NL'], ship_thrust['NS'],ship_fire['Y']))
        rule13_evade = ctrl.Rule((rel_ast_angl['NS'] & rel_ast_dist['Z']), (ship_turn['NL'], ship_thrust['NS'],ship_fire['Y']))
        rule14_evade = ctrl.Rule((rel_ast_angl['NS'] & rel_ast_dist['PS']), (ship_turn['NL'], ship_thrust['NS'],ship_fire['Y']))
        rule15_evade = ctrl.Rule((rel_ast_angl['NS'] & rel_ast_dist['PL']), (ship_turn['NL'], ship_thrust['NS'],ship_fire['Y']))

        rule16_evade = ctrl.Rule((rel_ast_angl['Z'] & rel_ast_dist['NL']), (ship_turn['PXL'], ship_thrust['NL'], ship_fire['Y']))
        rule17_evade = ctrl.Rule((rel_ast_angl['Z'] & rel_ast_dist['NS']), (ship_turn['Z'], ship_thrust['NL'], ship_fire['Y']))
        rule18_evade = ctrl.Rule((rel_ast_angl['Z'] & rel_ast_dist['Z']), (ship_turn['Z'], ship_thrust['NL'], ship_fire['Y']))
        rule19_evade = ctrl.Rule((rel_ast_angl['Z'] & rel_ast_dist['PS']), (ship_turn['Z'], ship_thrust['PS'], ship_fire['Y']))
        rule20_evade = ctrl.Rule((rel_ast_angl['Z'] & rel_ast_dist['PL']), (ship_turn['Z'], ship_thrust['PL'], ship_fire['Y']))

        rule21_evade = ctrl.Rule((rel_ast_angl['PS'] & rel_ast_dist['NL']), (ship_turn['PL'], ship_thrust['NS'],ship_fire['Y']))
        rule22_evade = ctrl.Rule((rel_ast_angl['PS'] & rel_ast_dist['NS']), (ship_turn['PL'], ship_thrust['NS'],ship_fire['Y']))
        rule23_evade = ctrl.Rule((rel_ast_angl['PS'] & rel_ast_dist['Z']), (ship_turn['PL'], ship_thrust['NS'],ship_fire['Y']))
        rule24_evade = ctrl.Rule((rel_ast_angl['PS'] & rel_ast_dist['PS']), (ship_turn['PL'], ship_thrust['NS'],ship_fire['Y']))
        rule25_evade = ctrl.Rule((rel_ast_angl['PS'] & rel_ast_dist['PL']), (ship_turn['PL'], ship_thrust['NS'],ship_fire['Y']))

        rule26_evade = ctrl.Rule((rel_ast_angl['PL'] & rel_ast_dist['NL']), (ship_turn['NXL'], ship_thrust['PL'],ship_fire['N']))
        rule27_evade = ctrl.Rule((rel_ast_angl['PL'] & rel_ast_dist['NS']), (ship_turn['NXL'], ship_thrust['PL'],ship_fire['N']))
        rule28_evade = ctrl.Rule((rel_ast_angl['PL'] & rel_ast_dist['Z']), (ship_turn['NXL'], ship_thrust['PL'],ship_fire['N']))
        rule29_evade = ctrl.Rule((rel_ast_angl['PL'] & rel_ast_dist['PS']), (ship_turn['NL'], ship_thrust['PS'],ship_fire['N']))
        rule30_evade = ctrl.Rule((rel_ast_angl['PL'] & rel_ast_dist['PL']), (ship_turn['NL'], ship_thrust['PS'],ship_fire['N']))

        rule31_evade = ctrl.Rule((rel_ast_angl['PXL'] & rel_ast_dist['NL']), (ship_turn['Z'], ship_thrust['PL'],ship_fire['Y']))
        rule32_evade = ctrl.Rule((rel_ast_angl['PXL'] & rel_ast_dist['NS']), (ship_turn['Z'], ship_thrust['PL'],ship_fire['N']))
        rule33_evade = ctrl.Rule((rel_ast_angl['PXL'] & rel_ast_dist['Z']), (ship_turn['PXL'], ship_thrust['PL'],ship_fire['N']))
        rule34_evade = ctrl.Rule((rel_ast_angl['PXL'] & rel_ast_dist['PS']), (ship_turn['NXL'], ship_thrust['PS'],ship_fire['N']))
        rule35_evade = ctrl.Rule((rel_ast_angl['PXL'] & rel_ast_dist['PL']), (ship_turn['NXL'], ship_thrust['PS'],ship_fire['N']))

        #rel_ast_angl.view()
        #rel_ast_dist.view()
        #ship_turn.view()
        #ship_thrust.view()
        #Evade mode Ruleset activation
        self.evade_control = ctrl.ControlSystem()
        self.evade_control.addrule(rule1_evade)
        self.evade_control.addrule(rule2_evade)
        self.evade_control.addrule(rule3_evade)
        self.evade_control.addrule(rule4_evade)
        self.evade_control.addrule(rule5_evade)
        self.evade_control.addrule(rule6_evade)
        self.evade_control.addrule(rule7_evade)
        self.evade_control.addrule(rule8_evade)
        self.evade_control.addrule(rule9_evade)
        self.evade_control.addrule(rule10_evade)
        self.evade_control.addrule(rule11_evade)
        self.evade_control.addrule(rule12_evade)
        self.evade_control.addrule(rule13_evade)
        self.evade_control.addrule(rule14_evade)
        self.evade_control.addrule(rule15_evade)
        self.evade_control.addrule(rule16_evade)
        self.evade_control.addrule(rule17_evade)
        self.evade_control.addrule(rule18_evade)
        self.evade_control.addrule(rule19_evade)
        self.evade_control.addrule(rule20_evade)
        self.evade_control.addrule(rule21_evade)
        self.evade_control.addrule(rule22_evade)
        self.evade_control.addrule(rule23_evade)
        self.evade_control.addrule(rule24_evade)
        self.evade_control.addrule(rule25_evade)
        self.evade_control.addrule(rule26_evade)
        self.evade_control.addrule(rule27_evade)
        self.evade_control.addrule(rule28_evade)
        self.evade_control.addrule(rule29_evade)
        self.evade_control.addrule(rule30_evade)
        self.evade_control.addrule(rule31_evade)
        self.evade_control.addrule(rule32_evade)
        self.evade_control.addrule(rule33_evade)
        self.evade_control.addrule(rule34_evade)
        self.evade_control.addrule(rule35_evade)
        

        

    def actions(self, ship_state: Dict, game_state: Dict) -> Tuple[float, float, bool]:
        """
        Method processed each time step by this controller.
        """

        # Find the closest asteroid (disregards asteroid velocity)
        ship_pos_x = ship_state["position"][0]
        ship_pos_y = ship_state["position"][1]       
        closest_asteroid = None
        
        for a in game_state["asteroids"]:
            #Loop through all asteroids, find minimum Eudlidean distance
            relative = relative_pos(a["position"][0], a["position"][1], a["velocity"][0], a["velocity"][1], ship_state["position"][0], ship_state["position"][1], ship_state["velocity"][0], ship_state["velocity"][1],a["radius"])

            if closest_asteroid is None :
                # Does not yet exist, so initialize first asteroid as the minimum. Ugh, how to do?
                closest_asteroid = dict(aster = a, dist = relative)
            else:    
                # closest_asteroid exists, and is thus initialized.
                if (closest_asteroid["dist"] > relative):
                    # New minimum found
                    closest_asteroid["aster"] = a
                    closest_asteroid["dist"] = relative


        # closest_asteroid is now the nearest asteroid object. 
        # Calculate intercept time given ship & asteroid position, asteroid velocity vector, bullet speed (not direction).
        # Based on Law of Cosines calculation, see notes.

        #Make a collection of danger radii to check how much danger the ship is in
        danger_low = ((closest_asteroid["dist"] + closest_asteroid["aster"]["radius"])<200)
        danger_medium = ((closest_asteroid["dist"] + closest_asteroid["aster"]["radius"])<150)
        danger_high = ((closest_asteroid["dist"] + closest_asteroid["aster"]["radius"])<100)
 
        # Side D of the triangle is given by closest_asteroid.dist. Need to get the asteroid-ship direction
        #    and the angle of the asteroid's current movement.

        asteroid_ship_x = ship_pos_x - closest_asteroid["aster"]["position"][0]
        asteroid_ship_y = ship_pos_y - closest_asteroid["aster"]["position"][1]
        
        asteroid_ship_theta = math.atan2(asteroid_ship_y,asteroid_ship_x)
        asteroid_direction = math.atan2(closest_asteroid["aster"]["velocity"][1], closest_asteroid["aster"]["velocity"][0]) # Velocity is a 2-element array [vx,vy].
        my_theta2 = asteroid_ship_theta - asteroid_direction
        cos_my_theta2 = math.cos(my_theta2)

        # Need the speeds of the asteroid and bullet. speed * time is distance to the intercept point
        asteroid_vel = math.sqrt(closest_asteroid["aster"]["velocity"][0]**2 + closest_asteroid["aster"]["velocity"][1]**2)

        bullet_speed = 800 # Hard-coded bullet speed from bullet.py

        #Need to look for ship speed to determine if any collisions imminent
        ship_speed = math.sqrt(ship_state["velocity"][0]**2 + ship_state["velocity"][1]**2)

        # Determinant of the quadratic formula b^2-4ac
        targ_det = (-2 * closest_asteroid["dist"] * asteroid_vel * cos_my_theta2)**2 - (4*(asteroid_vel**2 - bullet_speed**2) * closest_asteroid["dist"])
        evade_det = (-2 * closest_asteroid["dist"] * asteroid_vel * cos_my_theta2)**2 - (4*(asteroid_vel**2 - ship_speed**2) * closest_asteroid["dist"])

        # Combine the Law of Cosines with the quadratic formula for solve for intercept time. Remember, there are two values produced.
        intrcpt1 = ((2 * closest_asteroid["dist"] * asteroid_vel * cos_my_theta2) + math.sqrt(targ_det)) / (2 * (asteroid_vel**2 - bullet_speed**2))
        intrcpt2 = ((2 * closest_asteroid["dist"] * asteroid_vel * cos_my_theta2) - math.sqrt(targ_det)) / (2 * (asteroid_vel**2 - bullet_speed**2))

        evade_int1 = ((2 * closest_asteroid["dist"] * asteroid_vel * cos_my_theta2) + math.sqrt(abs(evade_det))) / (2 * (asteroid_vel**2 - ship_speed**2))
        evade_int2 = ((2 * closest_asteroid["dist"] * asteroid_vel * cos_my_theta2) - math.sqrt(abs(evade_det))) / (2 * (asteroid_vel**2 - ship_speed**2))

        # Take the smaller intercept time, as long as it is positive; if not, take the larger one for both shooting and evade mode
        if intrcpt1 > intrcpt2:
            if intrcpt2 >= 0:
                bullet_t = intrcpt2
            else:
                bullet_t = intrcpt1
        else:
            if intrcpt1 >= 0:
                bullet_t = intrcpt1
            else:
                bullet_t = intrcpt2
                
        if evade_int1 > evade_int2:
            if evade_int2 >= 0:
                ship_t = evade_int2
            else:
                ship_t = evade_int1
        else:
            if evade_int1 >= 0:
                ship_t = evade_int1
            else:
                ship_t = evade_int2
                        
        # Calculate the intercept point. The work backwards to find the ship's firing angle my_theta1.
        intrcpt_x = closest_asteroid["aster"]["position"][0] + closest_asteroid["aster"]["velocity"][0] * bullet_t
        intrcpt_y = closest_asteroid["aster"]["position"][1] + closest_asteroid["aster"]["velocity"][1] * bullet_t
        #Calculate the intercept point for the ship into the asteroid
        ship_intrcpt_x = closest_asteroid["aster"]["position"][0] + closest_asteroid["aster"]["velocity"][0] * ship_t
        ship_intrcpt_y = closest_asteroid["aster"]["position"][1] + closest_asteroid["aster"]["velocity"][1] * ship_t

        my_theta1 = math.atan2((intrcpt_y - ship_pos_y),(intrcpt_x - ship_pos_x))
        my_phi1 = math.atan2((ship_intrcpt_y - ship_pos_y),(ship_intrcpt_x - ship_pos_x))

        # Lastly, find the difference betwwen firing angle and the ship's current orientation. BUT THE SHIP HEADING IS IN DEGREES.
        shooting_theta = my_theta1 - ((math.pi/180)*ship_state["heading"])
        evade_theta = my_phi1 - ((math.pi/180)*ship_state["heading"])

        # Wrap all angles to (-pi, pi)
        shooting_theta = (shooting_theta + math.pi) % (2 * math.pi) - math.pi
        evade_theta = (evade_theta + math.pi) % (2 * math.pi) - math.pi


        # Pass the inputs to the rulebase and fire it
        #Evade asteroids if there are any within 150m else focus on shooting
        if(danger_high):
            evade = ctrl.ControlSystemSimulation(self.evade_control,flush_after_run=1)
            evade.input['rel_ast_angl'] = (180/math.pi)*evade_theta
            evade.input['rel_ast_dist'] = closest_asteroid["dist"]
            evade.compute()
            thrust = evade.output['ship_thrust']
            turn_rate = evade.output['ship_turn']
            if evade.output['ship_fire'] >= 0:
                fire = True
            else:
                fire = False  

        else:
            print("Shooting")
            shooting = ctrl.ControlSystemSimulation(self.targeting_control,flush_after_run=1)
            shooting.input['bullet_time'] = bullet_t
            shooting.input['theta_delta'] = (180/math.pi)*shooting_theta
            shooting.compute()
            thrust = 0
            turn_rate = shooting.output['ship_turn']
            if shooting.output['ship_fire'] >= 0:
                fire = True
            else:
                fire = False  

        
        self.eval_frames +=1
        
        #DEBUG
        print("Inputs")
        print(((180/math.pi)*evade_theta),closest_asteroid["dist"],((180/math.pi)*shooting_theta),bullet_t)
        print("Outputs")
        print(thrust, turn_rate, fire)
        
        return thrust, turn_rate, fire

    @property
    def name(self) -> str:
        return "Ivan's Controller"
